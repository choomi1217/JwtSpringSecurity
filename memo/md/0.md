# ...  망함
따라 배우려던 강의가 전부 Deprecated 됨..

그래서 
[스프링 문서](https://spring.io/guides/gs/securing-web/)
참고하기로 함 😂😂😂

# ... 망함2
[스프링 문서](https://spring.io/guides/gs/securing-web/) 이거 참고하려고 했는데..
아래 `antMatchers`라는게 자꾸 안 됨
```java
.authorizeHttpRequests((requests) -> requests
    .antMatchers("/", "/home").permitAll()
    .anyRequest().authenticated()
```

그래서 antMatchers도 안 되는건가 싶어서 HttpSecurity javadoc을 자세히 읽기 시작함.

---

RequestMatcher 구현(예: URL 패턴을 통해)을 사용하여 HttpServletRequest 를 기반으로 액세스를 제한할 수 있습니다.
예시 구성
가장 기본적인 예는 "ROLE_USER" 역할을 요구하도록 모든 URL을 구성하는 것입니다. 아래 구성에서는 모든 URL에 대한 인증이 필요하며 사용자 "admin" 및 "user" 모두에게 액세스 권한을 부여합니다.
@Configuration
@EnableWebSecurity
public class AuthorizeUrlsSecurityConfig {

  	@Bean
  	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
  		http
  			.authorizeHttpRequests((authorizeHttpRequests) ->
  				authorizeHttpRequests
  					.requestMatchers("/**").hasRole("USER")
  			)
  			.formLogin(withDefaults());
  		return http.build();
  	}
 
  	@Bean
  	public UserDetailsService userDetailsService() {
  		UserDetails user = User.withDefaultPasswordEncoder()
  			.username("user")
  			.password("password")
  			.roles("USER")
  			.build();
  		UserDetails admin = User.withDefaultPasswordEncoder()
  			.username("admin")
  			.password("password")
  			.roles("ADMIN", "USER")
  			.build();
  		return new InMemoryUserDetailsManager(user, admin);
  	}
}

여러 URL을 구성할 수도 있습니다. 아래 구성에서는 모든 URL에 대한 인증이 필요하며 "admin" 사용자에게만 /admin/으로 시작하는 URL에 대한 액세스 권한을 부여합니다. 사용자가 액세스할 수 있는 다른 모든 URL.
@Configuration
@EnableWebSecurity
public class AuthorizeUrlsSecurityConfig {

  	@Bean
  	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
  		http
  			.authorizeHttpRequests((authorizeHttpRequests) ->
  				authorizeHttpRequests
  					.requestMatchers("/admin/**").hasRole("ADMIN")
  					.requestMatchers("/**").hasRole("USER")
  			)
  			.formLogin(withDefaults());
  		return http.build();
  	}
 
  	@Bean
  	public UserDetailsService userDetailsService() {
  		UserDetails user = User.withDefaultPasswordEncoder()
  			.username("user")
  			.password("password")
  			.roles("USER")
  			.build();
  		UserDetails admin = User.withDefaultPasswordEncoder()
  			.username("admin")
  			.password("password")
  			.roles("ADMIN", "USER")
  			.build();
  		return new InMemoryUserDetailsManager(user, admin);
  	}
}

매처는 순서대로 고려됩니다. 따라서 첫 번째 매처가 모든 요청과 일치하고 두 번째 매핑에 도달하지 않기 때문에 다음은 유효하지 않습니다.
@Configuration
@EnableWebSecurity
public class AuthorizeUrlsSecurityConfig {

  	@Bean
  	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
  		http
  		 	.authorizeHttpRequests((authorizeHttpRequests) ->
  		 		authorizeHttpRequests
  			 		.requestMatchers("/**").hasRole("USER")
  			 		.requestMatchers("/admin/**").hasRole("ADMIN")
  		 	);
  		return http.build();
  	}
}

매개변수:
authorizeHttpRequestsCustomizer – AuthorizeHttpRequestsConfigurer.AuthorizationManagerRequestMatcherRegistry 에 대한 추가 옵션을 제공하는Customizer 프로그램
보고:
추가 사용자 지정을 위한 HttpSecurity
던지기:
Exception –
부터:
5.5